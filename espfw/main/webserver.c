
#include <driver/gpio.h>
#include <esp_crt_bundle.h>
#include <esp_http_client.h>
#include <esp_http_server.h>
#include <esp_https_ota.h>
#include <esp_log.h>
#include <esp_netif.h>
#include <esp_ota_ops.h>
#include <esp_random.h>
#include <nvs_flash.h>
#include <time.h>
#include "settings.h"
#include "webserver.h"

/* These are in foxesptemp_main.c */
extern struct ev evs[2];
extern int activeevs;
extern int pendingfwverify;
extern long too_wet_ctr;
extern int forcesht4xheater;
/* This is in network.c */
extern esp_netif_t * mainnetif;
static int settingshavechanged = 0;

/* How many admins can be logged in at the same time? */
#define MAXADMINLOGINS 3
/* And what is the maximum lifetime of an admin session, in seconds? */
#define MAXTOKENLIFETIME (30 * 60)
struct authtoken {
  time_t ts; /* When this token was handed out */
  uint8_t token[64]; /* the token. Always 63 bytes plus terminating \0 */
};
static struct authtoken liadmins[MAXADMINLOGINS];

/********************************************************
 * Embedded webpages definition. These are mostly       *
 * in external text files, to make editing them more    *
 * convenient.                                          *
 ********************************************************/

extern const uint8_t startp_p1[] asm("_binary_startpage_html_p00_start");
/* The following seems to exist in the autogenerated file, but it's
 * not documented - so lets avoid using it. */
/* extern uint16_t startp_p1_len asm("startpage_html_p00_length"); */

extern const uint8_t startp_p2[] asm("_binary_startpage_html_p01_start");

extern const uint8_t startpagejs[] asm("_binary_startpage_js_min_start");

extern const uint8_t csscss[] asm("_binary_css_css_min_start");

extern const uint8_t adminmenu_p1[] asm("_binary_adminmenu_html_p00_start");

extern const uint8_t adminmenu_p2[] asm("_binary_adminmenu_html_p01_start");

extern const uint8_t adminmenu_p3[] asm("_binary_adminmenu_html_p02_start");

static const uint8_t adminmenu_fww[] = R"EOAMFWW(
<br><b>A new firmware has been flashed,</b> and booted up (it's currently
running) - <b>but it has not been marked as &quot;good&quot; yet</b>.
Unless you mark the new firmware as &quot;good&quot;, on the next reset the old
firmware will be restored.<br>
<form action="adminaction" method="POST">
<input type="hidden" name="action" value="markfwasgood">
<input type="submit" name="su" value="Mark Firmware as Good"><br>
</form><br>
)EOAMFWW";

static const uint8_t pleaseloginfirstmsg[] = R"EOPLF(
You need to <a href="./#adminloginform">log in</a> before you can
access admin functions.
)EOPLF";

/********************************************************
 * End of embedded webpages definition                  *
 ********************************************************/

/* Helper functions */

/* Unescapes a x-www-form-urlencoded string.
 * Modifies the string inplace!
 * This is a mess that was quickly cobbled together. It
 * purposely excludes certain characters like " and ',
 * because we know all too well that we will print these
 * into html tags unescaped, and that would break with
 * these chars. We should at some time fix this by
 * using proper unescape AND escape functions, but for
 * now it's good enough for a tiny microcontroller. */
void unescapeuestring(uint8_t * s) {
  uint8_t * rp = s;
  uint8_t * wp = s;
  while (*rp != 0) {
    if (strncmp(rp, "+", 1) == 0) {
      *wp = ' '; wp++; rp++;
    } else if (strncmp(rp, "&amp;", 5) == 0) {
      *wp = '&'; rp += 5; wp += 1;
    } else if (strncmp(rp, "%20", 3) == 0) {
      *wp = ' '; rp += 3; wp += 1;
    } else if (strncmp(rp, "%21", 3) == 0) {
      *wp = '!'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%23", 3) == 0) {
      *wp = '#'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%24", 3) == 0) {
      *wp = '$'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%25", 3) == 0) {
      *wp = '%'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%26", 3) == 0) {
      *wp = '&'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%28", 3) == 0) {
      *wp = '('; rp += 3; wp += 1;
    } else if (strncmp(rp, "%29", 3) == 0) {
      *wp = ')'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2A", 3) == 0) {
      *wp = '*'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2B", 3) == 0) {
      *wp = '+'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2C", 3) == 0) {
      *wp = ','; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2D", 3) == 0) {
      *wp = '-'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2E", 3) == 0) {
      *wp = '.'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%2F", 3) == 0) {
      *wp = '/'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%3A", 3) == 0) {
      *wp = ':'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%3B", 3) == 0) {
      *wp = ';'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%3D", 3) == 0) {
      *wp = '='; rp += 3; wp += 1;
    } else if (strncmp(rp, "%3F", 3) == 0) {
      *wp = '?'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%40", 3) == 0) {
      *wp = '@'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%5B", 3) == 0) {
      *wp = '['; rp += 3; wp += 1;
    } else if (strncmp(rp, "%5D", 3) == 0) {
      *wp = ']'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%5E", 3) == 0) {
      *wp = '^'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%5F", 3) == 0) {
      *wp = '_'; rp += 3; wp += 1;
    } else if (strncmp(rp, "%7E", 3) == 0) {
      *wp = '~'; rp += 3; wp += 1;
    } else {
      *wp = *rp; wp++; rp++;
    }
  }
  *wp = 0;
}

/* Expires auth tokens. Those that have exceeded MAXTOKENLIFETIME will be
 * removed from the list. */
void expireauthtokens() {
  for (int i = 0; i < MAXADMINLOGINS; i++) {
    if ((liadmins[i].ts + MAXTOKENLIFETIME) < time(NULL)) {
      liadmins[i].ts = 0;
      strcpy(liadmins[i].token, "");
    }
  }
}

static const uint8_t tokchars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

/* Creates a new entry in the list of logged in admins (liadmins[]).
 * If there is no space, one of the oldest entries will be overwritten, thereby
 * invalidating the session using it.
 * Returns a pointer to the generated new token - as it points to the entry in
 * liadmins[], it naturally must not be modified outside of this function. */
uint8_t * createnewauthtoken(void) {
  expireauthtokens();
  int selectedslot = 0;
  time_t mints = 0;
  for (int i = 0; i < MAXADMINLOGINS; i++) {
    if (liadmins[i].ts < mints) {
      selectedslot = i;
    }
  }
  liadmins[selectedslot].ts = time(NULL);
  for (int i = 0; i < 63; i++) {
    liadmins[selectedslot].token[i] = tokchars[esp_random() % strlen(tokchars)];
  }
  liadmins[selectedslot].token[63] = 0;
  return &(liadmins[selectedslot].token[0]);
}

/* Checks whether the HTTP request contains a valid authtoken cookie, i.e. the
 * user is a logged in admin.
 * Returns 1 if it does, or 0 if it does not.
 */
int checkauthtoken(httpd_req_t * req) {
  expireauthtokens(); // Clears expired ones, so we don't have to test for expiry below
  uint8_t tokenfromrequest[64];
  size_t tfrsize = sizeof(tokenfromrequest);
  esp_err_t e = httpd_req_get_cookie_val(req, "authtoken", tokenfromrequest, &tfrsize);
  if (e != ESP_OK) {
    if (e != ESP_ERR_NOT_FOUND) {
      ESP_LOGW("webserver.c", "WARNING: Shenanigans with authtokens, Error %s on get_cookie_val", esp_err_to_name(e));
    }
    return 0;
  }
  tokenfromrequest[63] = 0;
  if (strlen(tokenfromrequest) < 63) {
    ESP_LOGW("webserver.c", "invalid (too short) authtoken %s submitted by client.", tokenfromrequest);
    return 0;
  }
  for (int i = 0; i < MAXADMINLOGINS; i++) {
    if (strcmp(tokenfromrequest, liadmins[i].token) == 0) {
      /* This is a valid token. */
      return 1;
    }
  }
  /* Token is not in the list of valid tokens. */
  return 0;
}

/* Page handlers */

esp_err_t get_startpage_handler(httpd_req_t * req) {
  uint8_t myresponse[3000]; /* approx 1000 for the startpage and 2000 for the content we insert below. */
  uint8_t * pfp;
  int e = activeevs;
  strcpy(myresponse, startp_p1);
  pfp = myresponse + strlen(startp_p1);
  pfp += sprintf(pfp, "<table><tr><th>UpdateTS</th><td id=\"ts\">%lld</td></tr>", evs[e].lastupd);
  if (settings.sht4x_i2cport > 0) { // SHT4X is enabled
    pfp += sprintf(pfp, "<tr><th>LastSHT4xHeaterTS</th><td id=\"lastsht4xheat\">%lld</td></tr>", evs[e].lastsht4xheat);
    pfp += sprintf(pfp, "<tr><th>Temperature (C)</th><td id=\"temp\">%.2f</td></tr>", evs[e].temp);
    pfp += sprintf(pfp, "<tr><th>Humidity (%%)</th><td id=\"hum\">%.1f</td></tr>", evs[e].hum);
  }
  if (settings.sen50_i2cport > 0) { // SEN50 is enabled
    pfp += sprintf(pfp, "<tr><th>PM 1.0 (&micro;g/m&sup3;)</th><td id=\"pm010\">%.1f</td></tr>", evs[e].pm010);
    pfp += sprintf(pfp, "<tr><th>PM 2.5 (&micro;g/m&sup3;)</th><td id=\"pm025\">%.1f</td></tr>", evs[e].pm025);
    pfp += sprintf(pfp, "<tr><th>PM 4.0 (&micro;g/m&sup3;)</th><td id=\"pm040\">%.1f</td></tr>", evs[e].pm040);
    pfp += sprintf(pfp, "<tr><th>PM 10.0 (&micro;g/m&sup3;)</th><td id=\"pm100\">%.1f</td></tr>", evs[e].pm100);
  }
  if (settings.lps35hw_i2cport > 0) { // LPS35HW is enabled
    pfp += sprintf(pfp, "<tr><th>Pressure (hPa)</th><td id=\"press\">%.3f</td></tr>", evs[e].press);
  }
  pfp += sprintf(pfp, "<tr><th>Rain (mm/min)</th><td id=\"raing\">%.2f</td></tr>", evs[e].raing);
  if (settings.scd41_i2cport > 0) { // SCD41 is enabled
    if (evs[e].co2 == 0xffff) { // Invalid - note that we cannot simply rely on
      // NAN being printed as NaN as with the other values because it's not a float.
      pfp += sprintf(pfp, "%s", "<tr><th>CO2 (ppm)</th><td id=\"co2\">nan</td></tr>");
    } else {
      pfp += sprintf(pfp, "<tr><th>CO2 (ppm)</th><td id=\"co2\">%u</td></tr>", evs[e].co2);
    }
  }
  pfp += sprintf(pfp, "</table>");
  strcat(myresponse, startp_p2);
  /* The following two lines are the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "text/html; charset=utf-8");
  httpd_resp_set_hdr(req, "Cache-Control", "public, max-age=29");
  httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_startpage = {
  .uri      = "/",
  .method   = HTTP_GET,
  .handler  = get_startpage_handler,
  .user_ctx = NULL
};

esp_err_t get_json_handler(httpd_req_t * req) {
  uint8_t myresponse[1100];
  uint8_t * pfp;
  int e = activeevs;
  strcpy(myresponse, "");
  pfp = myresponse;
  pfp += sprintf(pfp, "{");
  if (settings.sht4x_i2cport > 0) { // SHT4X is enabled
    pfp += sprintf(pfp, "\"lastsht4xheat\":\"%lld\",", evs[e].lastsht4xheat);
    pfp += sprintf(pfp, "\"temp\":\"%.2f\",", evs[e].temp);
    pfp += sprintf(pfp, "\"hum\":\"%.1f\",", evs[e].hum);
  }
  if (settings.sen50_i2cport > 0) { // SEN50 is enabled
    pfp += sprintf(pfp, "\"pm010\":\"%.1f\",", evs[e].pm010);
    pfp += sprintf(pfp, "\"pm025\":\"%.1f\",", evs[e].pm025);
    pfp += sprintf(pfp, "\"pm040\":\"%.1f\",", evs[e].pm040);
    pfp += sprintf(pfp, "\"pm100\":\"%.1f\",", evs[e].pm100);
  }
  if (settings.lps35hw_i2cport > 0) { // LPS35HW is enabled
    pfp += sprintf(pfp, "\"press\":\"%.3f\",", evs[e].press);
  }
  pfp += sprintf(pfp, "\"raing\":\"%.2f\",", evs[e].raing);
  if (settings.scd41_i2cport > 0) { // SCD41 is enabled
    if (evs[e].co2 == 0xffff) {
      pfp += sprintf(pfp, "%s", "\"co2\":\"nan\",");
    } else {
      pfp += sprintf(pfp, "\"co2\":\"%u\",", evs[e].co2);
    }
  }
  pfp += sprintf(pfp, "\"ts\":\"%lld\"}", evs[e].lastupd);
  /* The following line is the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "application/json");
  httpd_resp_set_hdr(req, "Cache-Control", "public, max-age=29");
  httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_json = {
  .uri      = "/json",
  .method   = HTTP_GET,
  .handler  = get_json_handler,
  .user_ctx = NULL
};

esp_err_t get_publicdebug_handler(httpd_req_t * req) {
  uint8_t myresponse[2000];
  uint8_t * pfp;
  strcpy(myresponse, "");
  pfp = myresponse;
  pfp += sprintf(pfp, "<html><head><title>Debug info (public part)</title></head><body>");
  pfp += sprintf(pfp, "too_wet_ctr: %ld<br>", too_wet_ctr);
  esp_netif_ip_info_t ip_info;
  pfp += sprintf(pfp, "My IP addresses:<br><ul>");
  if (esp_netif_get_ip_info(mainnetif, &ip_info) == ESP_OK) {
    pfp += sprintf(pfp, "<li>IPv4: " IPSTR "/" IPSTR " GW " IPSTR "</li>",
                   IP2STR(&ip_info.ip), IP2STR(&ip_info.netmask),
                   IP2STR(&ip_info.gw));
  } else {
    pfp += sprintf(pfp, "<li>Failed to get IPv4 address information :(</li>");
  }
  esp_ip6_addr_t v6addrs[CONFIG_LWIP_IPV6_NUM_ADDRESSES + 5];
  int nv6ips = esp_netif_get_all_ip6(mainnetif, v6addrs);
  for (int i = 0; i < nv6ips; i++) {
    pfp += sprintf(pfp, "<li>IPv6: " IPV6STR "</li>",
           IPV62STR(v6addrs[i]));
  }
  pfp += sprintf(pfp, "</ul>");
  pfp += sprintf(pfp, "Last reset reason: %d<br>", esp_reset_reason());
  /* The following line is the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "text/html; charset=utf-8");
  httpd_resp_set_hdr(req, "Cache-Control", "public, max-age=29");
  httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_debug = {
  .uri      = "/debug",
  .method   = HTTP_GET,
  .handler  = get_publicdebug_handler,
  .user_ctx = NULL
};

esp_err_t get_publicstartpagejs_handler(httpd_req_t * req) {
  /* The following line is the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "text/javascript");
  httpd_resp_set_hdr(req, "Cache-Control", "public, max-age=86400");
  httpd_resp_send(req, startpagejs, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_startpage_js = {
  .uri      = "/startpage.js",
  .method   = HTTP_GET,
  .handler  = get_publicstartpagejs_handler,
  .user_ctx = NULL
};

esp_err_t get_publiccss_handler(httpd_req_t * req) {
  /* The following line is the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "text/css");
  httpd_resp_set_hdr(req, "Cache-Control", "public, max-age=86400");
  httpd_resp_send(req, csscss, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_css_css = {
  .uri      = "/css.css",
  .method   = HTTP_GET,
  .handler  = get_publiccss_handler,
  .user_ctx = NULL
};

static uint8_t getu8setting(nvs_handle_t nvshandle, const uint8_t * key) {
  uint8_t res = 0;
  esp_err_t e = nvs_get_u8(nvshandle, key, &res);
  if ((e != ESP_OK) && (e != ESP_ERR_NVS_NOT_FOUND)) {
    ESP_LOGW("webserver.c", "failed to load u8 setting %s: %s", key, esp_err_to_name(e));
  }
  return res;
}

static void getstrsetting(nvs_handle_t nvshandle, const char * key, char * out, size_t len)
{
  size_t l = len;
  memset(out, 0, len);
  esp_err_t e = nvs_get_str(nvshandle, key, out, &l);
  if ((e != ESP_OK) && (e != ESP_ERR_NVS_NOT_FOUND)) {
    ESP_LOGW("webserver.c", "failed to load str setting %s: %s", key, esp_err_to_name(e));
  }
}

/* Helper to print the options for all valid GPIO pins inside a HTML select,
 * with one selected.
 * par1: pointer to where to put it (string)
 * par2: which GPIO is selected - 0 for 'disabled', 1 for GPIO0, 2 for GPIO1,
 *       3 for GPIO2, (n+1) for GPIO(n).
 * returns pointer to the end of the string after printing. */
uint8_t * printhtmlgpiosel(uint8_t * staptr, uint8_t selg)
{
  staptr += sprintf(staptr, "<option value=\"0\"%s>disabled</option>", ((selg == 0) ? " selected" : ""));
  for (int i = 0; i < 63; i++) {
    if (GPIO_IS_VALID_GPIO(i)) {
      staptr += sprintf(staptr, "<option value=\"%d\"%s>%d</option>", (i + 1), ((selg == (i + 1)) ? " selected" : ""), i);
    }
  }
  return staptr;
}

esp_err_t get_adminmenu_handler(httpd_req_t * req) {
  uint8_t * myresponse; /* This is going to be too large to just put it on the stack. */
  uint8_t * pfp;
  uint8_t tmp1[600];
  uint8_t subpage[50];
  uint8_t curs;
  if (checkauthtoken(req) != 1) {
    httpd_resp_set_status(req, "403 Forbidden");
    httpd_resp_send(req, pleaseloginfirstmsg, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  /* Get selected subpage (if any) */
  if (httpd_req_get_url_query_str(req, tmp1, sizeof(tmp1)-1) == ESP_OK) {
    /* We have a query string. Is there a sp=...? */
    if (httpd_query_key_value(tmp1, "sp", subpage, sizeof(subpage)-1) != ESP_OK) {
      strcpy(subpage, "main");
    } else {
      /* Nothing else to do - there was a sp parameter and it has been filled */
    }
  } else {
    strcpy(subpage, "main");
  }
  myresponse = calloc(10000, 1); /* FIXME calculate a realistic size */
  if (myresponse == NULL) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Out of memory.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  nvs_handle_t nvshandle;
  memset(&nvshandle, 0, sizeof(nvshandle));
  if (nvs_open("settings", NVS_READONLY, &nvshandle) != ESP_OK) {
    ESP_LOGW("webserver.c", "Failed to open settings in flash - this will cause"
                            " lots of consequential ESP_ERR_NVS_INVALID_HANDLE"
                            " errors directly below this.");
  }
  if (strcmp(subpage, "main") == 0) { /* Main page - this includes the others via JS */
    strcpy(myresponse, adminmenu_p1);
    pfp = myresponse + strlen(myresponse);
    const esp_app_desc_t * appd = esp_app_get_description();
    pfp += sprintf(pfp, "%s version %s compiled %s %s",
                   appd->project_name, appd->version, appd->date, appd->time);
    strcat(pfp, adminmenu_p2);
    if (pendingfwverify > 0) { /* notification that firmware has not been marked as good yet */
      strcat(pfp, adminmenu_fww);
    }
    strcat(pfp, adminmenu_p3);
  } else if (strcmp(subpage, "setwifi") == 0) { /* WiFi settings */
    strcpy(myresponse, "<form action=\"savesettings\" method=\"POST\" onsubmit=\"submitsettings(event)\">");
    strcat(myresponse, "<table><tr><th><label for=\"wifi_mode\">WiFi mode:</label></th><td>");
    strcat(myresponse, "<select name=\"wifi_mode\" id=\"wifi_mode\">");
    curs = getu8setting(nvshandle, "wifi_mode");
    pfp = myresponse + strlen(myresponse);
    pfp += sprintf(pfp, "<option value=\"0\"%s>Access Point</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>Client</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr><tr><th colspan=\"2\">For AccessPoint-Mode:</th></tr>");
    pfp += sprintf(pfp, "%s", "<tr><th><label for=\"wifi_ap_ssid\">WiFi SSID:</label></th><td>");
    getstrsetting(nvshandle, "wifi_ap_ssid", tmp1, sizeof(tmp1));
    if (strlen(tmp1) == 0) { // for this setting, if there is no setting in flash,
      // we will as an exception take the currently active value (which will be
      // a sane default generated from the MAC) from the settings variable.
      strcpy(tmp1, settings.wifi_ap_ssid);
    }
    pfp += sprintf(pfp, "<input type=\"text\" name=\"wifi_ap_ssid\" id=\"wifi_ap_ssid\" value=\"%s\"></td></tr>", tmp1);
    pfp += sprintf(pfp, "%s", "<tr><th><label for=\"wifi_ap_pw\">WiFi password (leave empty for 'open' mode):</label></th><td>");
    getstrsetting(nvshandle, "wifi_ap_pw", tmp1, sizeof(tmp1));
    pfp += sprintf(pfp, "<input type=\"text\" name=\"wifi_ap_pw\" id=\"wifi_ap_pw\" value=\"%s\"></td></tr>", tmp1);
    pfp += sprintf(pfp, "%s", "<tr><th colspan=\"2\">For Client-Mode:</th></tr>");
    pfp += sprintf(pfp, "%s", "<tr><th><label for=\"wifi_cl_ssid\">WiFi SSID:</label></th>");
    getstrsetting(nvshandle, "wifi_cl_ssid", tmp1, sizeof(tmp1));
    pfp += sprintf(pfp, "<td><input type=\"text\" name=\"wifi_cl_ssid\" id=\"wifi_cl_ssid\" value=\"%s\"></td></tr>", tmp1);
    pfp += sprintf(pfp, "%s", "<tr><th><label for=\"wifi_cl_pw\">WiFi password:</label></th>");
    getstrsetting(nvshandle, "wifi_cl_pw", tmp1, sizeof(tmp1));
    pfp += sprintf(pfp, "<td><input type=\"text\" name=\"wifi_cl_pw\" id=\"wifi_cl_pw\" value=\"%s\"></td></tr>", tmp1);
    strcat(pfp, "<tr><th colspan=\"2\"><input type=\"submit\" name=\"su\" value=\"Set\"></th></tr>");
    strcat(pfp, "</table></form><br>");
  } else if (strcmp(subpage, "setwiring") == 0) { /* External Wiring settings */
    strcpy(myresponse, "<form action=\"savesettings\" method=\"POST\" onsubmit=\"submitsettings(event)\">");
    strcat(myresponse, "<table>");
    for (int i2cport = 0; i2cport <= 1; i2cport++) {
      pfp = myresponse + strlen(myresponse);
      pfp += sprintf(pfp, "<tr><th>I2C %d GPIOs</th><td><label for=\"i2c_%d_scl\">SCL:</label>", i2cport, i2cport);
      pfp += sprintf(pfp, "<select name=\"i2c_%d_scl\" id=\"i2c_%d_scl\">", i2cport, i2cport);
      sprintf(tmp1, "i2c_%d_scl", i2cport);
      curs = getu8setting(nvshandle, tmp1);
      pfp = printhtmlgpiosel(pfp, curs);
      pfp += sprintf(pfp, "</select> <label for=\"i2c_%d_scl\">SDA:</label>", i2cport);
      pfp += sprintf(pfp, "<select name=\"i2c_%d_sda\" id=\"i2c_%d_sda\">", i2cport, i2cport);
      sprintf(tmp1, "i2c_%d_sda", i2cport);
      curs = getu8setting(nvshandle, tmp1);
      pfp = printhtmlgpiosel(pfp, curs);
      pfp += sprintf(pfp, "%s", "</select><br>");
      sprintf(tmp1, "i2c_%d_pullups", i2cport);
      curs = getu8setting(nvshandle, tmp1);
      pfp += sprintf(pfp, "<select id=\"i2c_%d_pullups\" name=\"i2c_%d_pullups\">", i2cport, i2cport);
      pfp += sprintf(pfp, "<option value=\"0\"%s>Disable pullups</option>", ((curs == 0) ? " selected" : ""));
      pfp += sprintf(pfp, "<option value=\"1\"%s>Enable pullups</option>", ((curs == 1) ? " selected" : ""));
      pfp += sprintf(pfp, "%s", "</select><br><label for=\"i2c_%d_speed\">Speed (Hz):</label>");
      sprintf(tmp1, "i2c_%d_speed", i2cport);
      curs = getu8setting(nvshandle, tmp1);
      pfp += sprintf(pfp, "<select id=\"i2c_%d_speed\" name=\"i2c_%d_speed\">", i2cport, i2cport);
      pfp += sprintf(pfp, "<option value=\"0\"%s>100k (default)</option>", ((curs == 0) ? " selected" : ""));
      pfp += sprintf(pfp, "<option value=\"1\"%s>25k</option>", ((curs == 1) ? " selected" : ""));
      pfp += sprintf(pfp, "<option value=\"2\"%s>200k</option>", ((curs == 2) ? " selected" : ""));
      pfp += sprintf(pfp, "<option value=\"3\"%s>400k</option>", ((curs == 3) ? " selected" : ""));
      pfp += sprintf(pfp, "<option value=\"4\"%s>1000k</option>", ((curs == 4) ? " selected" : ""));
      pfp += sprintf(pfp, "%s", "</select></td></tr>");
    }
    pfp += sprintf(pfp, "%s", "<tr><th>Serial 1 GPIOs</th><td><label for=\"ser_1_rx\">RX:</label>");
    pfp += sprintf(pfp, "%s", "<select name=\"ser_1_rx\" id=\"ser_1_rx\">");
    curs = getu8setting(nvshandle, "ser_1_rx");
    pfp = printhtmlgpiosel(pfp, curs);
    pfp += sprintf(pfp, "%s", "</select> <label for=\"ser_1_tx\">TX:</label>");
    pfp += sprintf(pfp, "%s", "<select name=\"ser_1_tx\" id=\"ser_1_tx\">");
    curs = getu8setting(nvshandle, "ser_1_tx");
    pfp = printhtmlgpiosel(pfp, curs);
    strcat(pfp, "</select></td></tr>");
    strcat(pfp, "<tr><th colspan=\"2\"><input type=\"submit\" name=\"su\" value=\"Set\"></th></tr>");
    strcat(pfp, "</table></form><br>");
  } else if (strcmp(subpage, "setsensors") == 0) { /* Sensor settings */
    strcpy(myresponse, "<form action=\"savesettings\" method=\"POST\" onsubmit=\"submitsettings(event)\">");
    strcat(myresponse, "<table>");
    pfp = myresponse + strlen(myresponse);
    /* I2C sensors */
    curs = getu8setting(nvshandle, "scd41_i2cport");
    pfp += sprintf(pfp, "%s", "<tr><th>SCD41</th><td>");
    pfp += sprintf(pfp, "%s", "<label for=\"scd41_i2cport\">I2C Port</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"scd41_i2cport\" id=\"scd41_i2cport\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>not connected</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>I2C 0</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>I2C 1</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select><br><label for=\"scd41_selfcal\">");
    curs = getu8setting(nvshandle, "scd41_selfcal");
    pfp += sprintf(pfp, "%s", "<abbr title=\"Automatic Self Calibration\">ASC</abbr>:</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"scd41_selfcal\" id=\"scd41_selfcal\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>use EEPROM setting</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>Enable</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>Disable</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr>");
    curs = getu8setting(nvshandle, "sen50_i2cport");
    pfp += sprintf(pfp, "%s", "<tr><th>SEN50</th><td>");
    pfp += sprintf(pfp, "%s", "<label for=\"sen50_i2cport\">I2C Port</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"sen50_i2cport\" id=\"sen50_i2cport\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>not connected</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>I2C 0</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>I2C 1</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr>");
    curs = getu8setting(nvshandle, "sht4x_i2cport");
    pfp += sprintf(pfp, "%s", "<tr><th>SHT4x (SHT40/SHT41/SHT45)</th><td>");
    pfp += sprintf(pfp, "%s", "<label for=\"sht4x_i2cport\">I2C Port</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"sht4x_i2cport\" id=\"sht4x_i2cport\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>not connected</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>I2C 0</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>I2C 1</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select><br><label for=\"sht4x_addr\">address</label>:");
    curs = getu8setting(nvshandle, "sht4x_addr");
    pfp += sprintf(pfp, "%s", "<select name=\"sht4x_addr\" id=\"sht4x_addr\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>0x44 (most common)</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>0x45</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>0x46</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr>");
    curs = getu8setting(nvshandle, "lps35hw_i2cport");
    pfp += sprintf(pfp, "%s", "<tr><th>LPS35HW</th><td>");
    pfp += sprintf(pfp, "%s", "<label for=\"lps35hw_i2cport\">I2C Port</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"lps35hw_i2cport\" id=\"lps35hw_i2cport\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>not connected</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>I2C 0</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"2\"%s>I2C 1</option>", ((curs == 2) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select><br><label for=\"lps35hw_addr\">address</label>:");
    curs = getu8setting(nvshandle, "lps35hw_addr");
    pfp += sprintf(pfp, "%s", "<select name=\"lps35hw_addr\" id=\"lps35hw_addr\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>0x5c</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>0x5d</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr>");
    /* serial sensor */
    curs = getu8setting(nvshandle, "rg15_serport");
    pfp += sprintf(pfp, "%s", "<tr><th>RG15</th><td>");
    pfp += sprintf(pfp, "%s", "<label for=\"rg15_serport\">Serial Port</label>:");
    pfp += sprintf(pfp, "%s", "<select name=\"rg15_serport\" id=\"rg15_serport\">");
    pfp += sprintf(pfp, "<option value=\"0\"%s>not connected</option>", ((curs == 0) ? " selected" : ""));
    pfp += sprintf(pfp, "<option value=\"1\"%s>Serial 1</option>", ((curs == 1) ? " selected" : ""));
    pfp += sprintf(pfp, "%s", "</select></td></tr>");
    strcat(pfp, "<tr><th colspan=\"2\"><input type=\"submit\" name=\"su\" value=\"Set\"></th></tr>");
    strcat(pfp, "</table></form><br>");
  } else if (strcmp(subpage, "setmisc") == 0) { /* Misc settings */
    strcpy(myresponse, "<form action=\"savesettings\" method=\"POST\" onsubmit=\"submitsettings(event)\">");
    strcat(myresponse, "<table>");
    strcat(myresponse, "<tr><th>Change Admin Password</th><td>");
    strcat(myresponse, "<label for=\"curadminpw\">Current Password:</label>");
    strcat(myresponse, "<input type=\"text\" name=\"curadminpw\" id=\"curadminpw\" value=\"\"><br>");
    strcat(myresponse, "<label for=\"adminpw\">New Password:</label>");
    strcat(myresponse, "<input type=\"text\" name=\"adminpw\" id=\"adminpw\" value=\"\"><br>");
    strcat(myresponse, "<label for=\"repadminpw\">Repeat New Password:</label>");
    strcat(myresponse, "<input type=\"text\" name=\"repadminpw\" id=\"repadminpw\" value=\"\"></td></tr>");
    strcat(myresponse, "<tr><th colspan=\"2\"><input type=\"submit\" name=\"su\" value=\"Set\"></th></tr>");
    strcat(myresponse, "</table></form><br>");
  } else {
    strcpy(myresponse, "??? Unknown subpage requested.");
  }
  /* The following two lines are the default und thus redundant. */
  httpd_resp_set_status(req, "200 OK");
  httpd_resp_set_type(req, "text/html; charset=utf-8");
  httpd_resp_set_hdr(req, "Cache-Control", "private, max-age=29");
  httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  free(myresponse);
  return ESP_OK;
}

static httpd_uri_t uri_adminmenu = {
  .uri      = "/adminmenu.html",
  .method   = HTTP_GET,
  .handler  = get_adminmenu_handler,
  .user_ctx = NULL
};

esp_err_t post_adminlogin(httpd_req_t * req) {
  uint8_t postcontent[600];
  uint8_t tmp1[600];
  //ESP_LOGI("webserver.c", "POST request with length: %d", req->content_len);
  if (req->content_len >= sizeof(postcontent)) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Sorry, your request was too large. Try another browser?", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  int ret = httpd_req_recv(req, postcontent, req->content_len);
  if (ret < req->content_len) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Your request was incompletely received.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  postcontent[req->content_len] = 0;
  ESP_LOGI("webserver.c", "Received data: '%s'", postcontent);
  if (httpd_query_key_value(postcontent, "adminpw", tmp1, sizeof(tmp1)) != ESP_OK) {
    httpd_resp_set_status(req, "400 Bad Request");
    httpd_resp_send(req, "No adminpw submitted.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  unescapeuestring(tmp1);
  if (strcmp(tmp1, settings.adminpw) != 0) {
    ESP_LOGI("webserver.c", "Incorrect AdminPW - UE: '%s'", tmp1);
    httpd_resp_set_status(req, "403 Forbidden");
    httpd_resp_send(req, "Admin-Password incorrect.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  /* generate token, send cookie, redirect to adminmenu.html */
  httpd_resp_set_status(req, "303 See Other");
  httpd_resp_set_hdr(req, "Location", "adminmenu.html");
  sprintf(tmp1, "authtoken=%s; Max-Age=%d", createnewauthtoken(), MAXTOKENLIFETIME);
  httpd_resp_set_hdr(req, "Set-Cookie", tmp1);
  httpd_resp_send(req, "Redirecting...", HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_adminlogin = {
  .uri      = "/adminlogin",
  .method   = HTTP_POST,
  .handler  = post_adminlogin,
  .user_ctx = NULL
};

esp_err_t post_adminaction(httpd_req_t * req) {
  uint8_t postcontent[600];
  uint8_t myresponse[1000];
  uint8_t tmp1[200];
  if (checkauthtoken(req) != 1) {
    httpd_resp_set_status(req, "403 Forbidden");
    httpd_resp_send(req, pleaseloginfirstmsg, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  //ESP_LOGI("webserver.c", "POST request with length: %d", req->content_len);
  if (req->content_len >= sizeof(postcontent)) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Sorry, your request was too large. Try a shorter update URL?", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  int ret = httpd_req_recv(req, postcontent, req->content_len);
  if (ret < req->content_len) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Your request was incompletely received.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  postcontent[req->content_len] = 0;
  ESP_LOGI("webserver.c", "Received data: '%s'", postcontent);
  if (httpd_query_key_value(postcontent, "action", tmp1, sizeof(tmp1)) != ESP_OK) {
    httpd_resp_set_status(req, "400 Bad Request");
    httpd_resp_send(req, "No adminaction selected.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  if (strcmp(tmp1, "flashupdate") == 0) {
    if (httpd_query_key_value(postcontent, "updateurl", tmp1, sizeof(tmp1)) != ESP_OK) {
      httpd_resp_set_status(req, "400 Bad Request");
      httpd_resp_send(req, "No updateurl submitted.", HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    unescapeuestring(tmp1);
    ESP_LOGI("webserver.c", "UE UpdateURL: '%s'", tmp1);
    sprintf(myresponse, "OK, will try to update from: %s'<br>", tmp1);
    esp_http_client_config_t httpccfg = {
        .url = tmp1,
        .timeout_ms = 60000,
        .keep_alive_enable = true,
        .crt_bundle_attach = esp_crt_bundle_attach
    };
    esp_https_ota_config_t otacfg = {
        .http_config = &httpccfg
    };
    ret = esp_https_ota(&otacfg);
    if (ret == ESP_OK) {
      ESP_LOGI("webserver.c", "OTA Succeed, Rebooting...");
      strcat(myresponse, "OTA Update reported success. Will reboot.");
    strcat(myresponse, " <a href=\"./\">Reconnect after waiting for a few seconds.</a>");
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      vTaskDelay(3 * (1000 / portTICK_PERIOD_MS)); 
      esp_restart();
    } else {
      ESP_LOGE("webserver.c", "Firmware upgrade failed");
      strcat(myresponse, "OTA Update reported failure.");
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    /* This should not be reached. */
  } else if (strcmp(tmp1, "reboot") == 0) {
    ESP_LOGI("webserver.c", "Reboot requested by admin, Rebooting...");
    strcpy(myresponse, "OK, will reboot in 3 seconds.");
    strcat(myresponse, " <a href=\"./\">Reconnect after waiting for a few seconds.</a>");
    httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
    vTaskDelay(3 * (1000 / portTICK_PERIOD_MS)); 
    esp_restart();
    /* This should not be reached */
  } else if (strcmp(tmp1, "forcesht4xheater") == 0) {
    ESP_LOGI("webserver.c", "Forced SHT4x heating cycle requested by admin.");
    forcesht4xheater = 1;
    strcpy(myresponse, "OK, will do a SHT4x heating cycle after the next polling iteration.");
    httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  } else if (strcmp(tmp1, "markfwasgood") == 0) {
    if (pendingfwverify == 0) {
      httpd_resp_set_status(req, "400 Bad Request");
      strcpy(myresponse, "You're trying to mark an already marked firmware.");
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    ret = esp_ota_mark_app_valid_cancel_rollback();
    if (ret == ESP_OK) {
      ESP_LOGI("webserver.c", "markfirmwareasgood: Updated firmware is now marked as good.");
      strcpy(myresponse, "New firmware was successfully marked as good.");
      strcat(myresponse, " <a href=\"./\">Reconnect after waiting for a few seconds.</a>");
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
    } else {
      ESP_LOGE("webserver.c", "markfirmwareasgood: Failed to mark updated firmware as good, will rollback on next reboot.");
      strcpy(myresponse, "Failed to mark updated firmware as good, will rollback on next reboot.");
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
    }
    pendingfwverify = 0;
  } else {
    httpd_resp_set_status(req, "400 Bad Request");
    strcpy(myresponse, "Unknown adminaction requested.");
    httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  }
  return ESP_OK;
}

static httpd_uri_t uri_adminaction = {
  .uri      = "/adminaction",
  .method   = HTTP_POST,
  .handler  = post_adminaction,
  .user_ctx = NULL
};

struct strset_s {
  const uint8_t * name;
  int minlen;
  int maxlen;
};

struct u8set_s {
  const uint8_t * name;
  uint8_t minval;
  uint8_t maxval;
};

static const struct strset_s strsets[] = {
  { .name = "adminpw", .minlen = 0, .maxlen = 24 },
  { .name = "wifi_ap_ssid", .minlen = 2, .maxlen = 32 },
  { .name = "wifi_ap_pw", .minlen = 0, .maxlen = 63 },
  { .name = "wifi_cl_ssid", .minlen = 2, .maxlen = 32 },
  { .name = "wifi_cl_pw", .minlen = 0, .maxlen = 63 },
};

static const struct u8set_s u8sets[] = {
  { .name = "lps35hw_addr", .minval = 0, .maxval = 1 },
  { .name = "lps35hw_i2cport", .minval = 0, .maxval = 2 },
  { .name = "rg15_serport", .minval = 0, .maxval = 1 },
  { .name = "scd41_i2cport", .minval = 0, .maxval = 2 },
  { .name = "scd41_selfcal", .minval = 0, .maxval = 2 },
  { .name = "sen50_i2cport", .minval = 0, .maxval = 2 },
  { .name = "ser_1_rx", .minval = 0, .maxval = 64 },
  { .name = "ser_1_tx", .minval = 0, .maxval = 64 },
  { .name = "sht4x_addr", .minval = 0, .maxval = 2 },
  { .name = "sht4x_i2cport", .minval = 0, .maxval = 2 },
  { .name = "i2c_0_pullups", .minval = 0, .maxval = 1 },
  { .name = "i2c_0_scl", .minval = 0, .maxval = 64 },
  { .name = "i2c_0_sda", .minval = 0, .maxval = 64 },
  { .name = "i2c_0_speed", .minval = 0, .maxval = 4 },
  { .name = "i2c_1_pullups", .minval = 0, .maxval = 1 },
  { .name = "i2c_1_scl", .minval = 0, .maxval = 64 },
  { .name = "i2c_1_sda", .minval = 0, .maxval = 64 },
  { .name = "i2c_1_speed", .minval = 0, .maxval = 4 },
  { .name = "wifi_mode", .minval = 0, .maxval = 1 },
};

esp_err_t post_savesettings(httpd_req_t * req) {
  uint8_t postcontent[1000];
  uint8_t myresponse[1000];
  uint8_t tmp1[200];
  uint8_t tmp2[200];
  strcpy(myresponse, "OK.<br>");
  if (checkauthtoken(req) != 1) {
    httpd_resp_set_status(req, "403 Forbidden");
    httpd_resp_send(req, pleaseloginfirstmsg, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  //ESP_LOGI("webserver.c", "POST request with length: %d", req->content_len);
  if (req->content_len >= sizeof(postcontent)) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Sorry, your request was too large.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  int ret = httpd_req_recv(req, postcontent, req->content_len);
  if (ret < req->content_len) {
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Your request was incompletely received.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  postcontent[req->content_len] = 0;
  ESP_LOGI("webserver.c", "Received data: '%s'", postcontent);
  nvs_handle_t nvshandle;
  esp_err_t e = nvs_open("settings", NVS_READWRITE, &nvshandle);
  if (e != ESP_OK) {
    ESP_LOGE("webserver.c", "Failed to open settings in flash for writing: %s.",
                            esp_err_to_name(e));
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Error accessing non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  /* string values */
  for (int i = 0; i < (sizeof(strsets) / sizeof(struct strset_s)); i++) {
    if (httpd_query_key_value(postcontent, strsets[i].name, tmp1, sizeof(tmp1)) != ESP_OK) {
      continue; // No such setting in submitted values.
    }
    unescapeuestring(tmp1);
    if (strlen(tmp1) < strsets[i].minlen) {
      sprintf(myresponse, "ERROR: '%s' needs to be at least %d characters long.",
                          strsets[i].name, strsets[i].minlen);
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    if (strlen(tmp1) > strsets[i].maxlen) {
      sprintf(myresponse, "ERROR: '%s' can be at most %d characters long.",
                          strsets[i].name, strsets[i].maxlen);
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    /* Length seems OK. Those were the common sanity checks, now special cases: */
    if (strcmp(strsets[i].name, "adminpw") == 0) {
      if (strlen(tmp1) == 0) { /* Field empty, user does not want to change the password. */
        continue;
      }
      /* Changing the adminpw requires entering the old password, and the new
       * password twice. */
      if (httpd_query_key_value(postcontent, "curadminpw", tmp2, sizeof(tmp2)) != ESP_OK) {
        strcpy(myresponse, "ERROR: cannot change admin password - current password entered incorrectly.");
        httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
      unescapeuestring(tmp2);
      if (strcmp(tmp2, settings.adminpw) != 0) {
        strcpy(myresponse, "ERROR: cannot change admin password - current password entered incorrectly.");
        httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
      /* OK, so current password is entered correctly, are both fields for the new PW identical? */
      if (httpd_query_key_value(postcontent, "repadminpw", tmp2, sizeof(tmp2)) != ESP_OK) {
        strcpy(myresponse, "ERROR: cannot change admin password - new password entered incorrectly.");
        httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
      unescapeuestring(tmp2);
      if (strcmp(tmp2, tmp1) != 0) {
        strcpy(myresponse, "ERROR: cannot change admin password - fields for new password are not identical.");
        httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
    }
    /* Has the value changed? */
    size_t len = sizeof(tmp2);
    e = nvs_get_str(nvshandle, strsets[i].name, tmp2, &len);
    if ((e != ESP_OK) && (e != ESP_ERR_NVS_NOT_FOUND)) {
      ESP_LOGE("webserver.c", "Failed to query setting in flash: %s.",
                              esp_err_to_name(e));
      httpd_resp_set_status(req, "500 Internal Server Error");
      httpd_resp_send(req, "Error reading non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    if ((e == ESP_ERR_NVS_NOT_FOUND)
     || (strcmp(tmp1, tmp2) != 0)) { // OK, this setting has changed.
      // Write the changed value.
      e = nvs_set_str(nvshandle, strsets[i].name, tmp1);
      if (e != ESP_OK) {
        ESP_LOGE("webserver.c", "Failed to write changed setting to flash: %s.",
                                esp_err_to_name(e));
        httpd_resp_set_status(req, "500 Internal Server Error");
        httpd_resp_send(req, "Error writing non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
      settingshavechanged = 1;
      strcat(myresponse, "'");
      strcat(myresponse, strsets[i].name);
      strcat(myresponse, "' changed.<br>");
    }
  }
  /* u8 values */
  for (int i = 0; i < (sizeof(u8sets) / sizeof(struct u8set_s)); i++) {
    if (httpd_query_key_value(postcontent, u8sets[i].name, tmp1, sizeof(tmp1)) != ESP_OK) {
      continue; // No such setting in submitted values.
    }
    long newv = strtol(tmp1, NULL, 10);
    if ((newv < u8sets[i].minval) || (newv > u8sets[i].maxval)) {
      sprintf(myresponse, "ERROR: value %ld for '%s' is outside permitted range [%u...%u]",
                          newv, u8sets[i].name, u8sets[i].minval, u8sets[i].maxval);
      httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    /* Range is valid, has the value changed? */
    uint8_t oldv = 0;
    e = nvs_get_u8(nvshandle, u8sets[i].name, &oldv);
    if ((e != ESP_OK) && (e != ESP_ERR_NVS_NOT_FOUND)) {
      ESP_LOGE("webserver.c", "Failed to query setting in flash: %s.",
                              esp_err_to_name(e));
      httpd_resp_set_status(req, "500 Internal Server Error");
      httpd_resp_send(req, "Error reading non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
      return ESP_OK;
    }
    if ((e == ESP_ERR_NVS_NOT_FOUND)
     || (oldv != newv)) { // OK, this setting has changed.
      // Write the changed value.
      e = nvs_set_u8(nvshandle, u8sets[i].name, (uint8_t)newv);
      if (e != ESP_OK) {
        ESP_LOGE("webserver.c", "Failed to write changed setting to flash: %s.",
                                esp_err_to_name(e));
        httpd_resp_set_status(req, "500 Internal Server Error");
        httpd_resp_send(req, "Error writing non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
        return ESP_OK;
      }
      settingshavechanged = 1;
      strcat(myresponse, "'");
      strcat(myresponse, u8sets[i].name);
      strcat(myresponse, "' changed.<br>");
    }
  }
  e = nvs_commit(nvshandle);
  if (e != ESP_OK) {
    ESP_LOGE("webserver.c", "Failed to flush changed settings to flash: %s.",
                            esp_err_to_name(e));
    httpd_resp_set_status(req, "500 Internal Server Error");
    httpd_resp_send(req, "Error flushing non-volatile storage for settings.", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
  }
  nvs_close(nvshandle);
  httpd_resp_send(req, myresponse, HTTPD_RESP_USE_STRLEN);
  return ESP_OK;
}

static httpd_uri_t uri_savesettings = {
  .uri      = "/savesettings",
  .method   = HTTP_POST,
  .handler  = post_savesettings,
  .user_ctx = NULL
};

void webserver_start(void) {
  httpd_handle_t server = NULL;
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  /* Documentation is - as usual - a bit patchy, but I assume
   * the following drops the oldest connection if the ESP runs
   * out of connections. */
  config.lru_purge_enable = true;
  config.server_port = 80;
  config.max_uri_handlers = 16;
  /* The default is undocumented, but seems to be only 4k. */
  config.stack_size = 8192;
  ESP_LOGI("webserver.c", "Starting webserver on port %d", config.server_port);
  if (httpd_start(&server, &config) != ESP_OK) {
    ESP_LOGE("webserver.c", "Failed to start HTTP server.");
    return;
  }
  httpd_register_uri_handler(server, &uri_startpage);
  httpd_register_uri_handler(server, &uri_json);
  httpd_register_uri_handler(server, &uri_debug);
  httpd_register_uri_handler(server, &uri_startpage_js);
  httpd_register_uri_handler(server, &uri_css_css);
  httpd_register_uri_handler(server, &uri_adminlogin);
  httpd_register_uri_handler(server, &uri_adminmenu);
  httpd_register_uri_handler(server, &uri_adminaction);
  httpd_register_uri_handler(server, &uri_savesettings);
}

