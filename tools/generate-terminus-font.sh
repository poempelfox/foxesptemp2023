#!/bin/bash

# This scripts generates bitmap fonts for use with FoxESPTemp.
# This will work for a few font sizes that you can select on the
# commandline (until the width exceeds 16, at which point the
# shell magic will break completely).
# This is a pretty messy hack, and I'm very surprised it works as
# well as it does.

FN="/tmp/fontconv.xbm"

BYTESPERCHAR="2"
BOLD="norm"
WEIGHT=""

if [ "$1" == "13" ] ; then
  FONTHEIGHT=13
  FONTWIDTH=7
  POINTSIZE=12
  BYTESPERCHAR=1
elif [ "$1" == "16" ] ; then
  FONTHEIGHT=16
  FONTWIDTH=8
  POINTSIZE=14
  BYTESPERCHAR=1
elif [ "$1" == "19" ] ; then
  FONTHEIGHT=19
  FONTWIDTH=10
  POINTSIZE=18
elif [ "$1" == "24" ] ; then
  FONTHEIGHT=24
  FONTWIDTH=12
  POINTSIZE=22
elif [ "$1" == "26" ] ; then
  FONTHEIGHT=26
  FONTWIDTH=13
  POINTSIZE=24
elif [ "$1" == "28" ] ; then
  FONTHEIGHT=28
  FONTWIDTH=14
  POINTSIZE=26
elif [ "$1" == "30" ] ; then
  FONTHEIGHT=30
  FONTWIDTH=15
  POINTSIZE=28
elif [ "$1" == "32" ] ; then
  FONTHEIGHT=32
  FONTWIDTH=16
  POINTSIZE=30
elif [ "$1" == "34" ] ; then
  FONTHEIGHT=34
  FONTWIDTH=17
  POINTSIZE=32
  BYTESPERCHAR=3
else
  echo "Don't know how to handle font height $1."
  echo "Syntax: $0 fontheight [bold]"
  echo "Valid values for fontheight are:"
  echo "  16 (16 high /  8 wide)"
  echo "  19 (19 high / 10 wide)"
  echo "  24 (24 high / 12 wide)"
  echo "  26 (26 high / 13 wide)"
  echo "  28 (28 high / 14 wide)"
  echo "  30 (30 high / 15 wide)"
  echo "  32 (32 high / 16 wide)"
  echo "  34 (34 high / 17 wide - this does not actually work.)"
  echo "Valid values for bold are: 0 or 1, defaults to 0."
  exit 1
fi

if [ "$2" == "1" -o "$2" == "bold" ] ; then
  BOLD="bold"
  WEIGHT="-Bold"
fi

echo "/* Font definition: Terminus font in size ${FONTHEIGHT} pixels."
echo " * width is ${FONTWIDTH} pixels. This uses ${BYTESPERCHAR} bytes"
if [ "$BOLD" == "bold" ] ; then
  echo " * per character. Font weight was bold."
else
  echo " * per character. Font weight was normal."
fi
echo " * This was obviously generated by script from the TTF version"
echo " * of the font (because it gets harder and harder to use the"
echo " * original bitmap font)."
echo " * The Terminus Font is licensed under the SIL Open Font License,"
echo " * version 1.1."
echo " */"
echo ""
echo "#include \"font.h\""
echo ""
echo "const uint8_t terminus${FONTHEIGHT}${BOLD}_data[] = {"
let "offset=1"
declare -a coffs
for c in `seq 0 255`
do
  coffs[$c]="0"
done
# What doesn't work is generating the first character, the space,
# because imagemagick will refuse to create that empty image.
# Luckily the fix is simple, as space is just $FONTHEIGHT times 0x00...
echo "    /* Next character:   (space) (ord 32) at offset $offset */"
coffs[32]=1
for n in `seq 1 $FONTHEIGHT`
do
  if [ "$BYTESPERCHAR" == "1" ] ; then
    echo "    0x00, //         "
  elif [ "$BYTESPERCHAR" == "2" ] ; then
    echo "    0x00, 0x00, //                 "
  else
    echo "    0x00, 0x00, 0x00, //                         "
  fi
done

for c in "!" "\"" "#" "\$" "%" "&" "'" "(" ")" "*" "+" "," "-" "." "/" \
         0 1 2 3 4 5 6 7 8 9 ":" ";" "<" "=" ">" "?" "@" \
         A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
         "[" "\\\\" "]" "^" "_" "\`" \
         a b c d e f g h i j k l m n o p q r s t u v w x y z \
         "{" "|" "}" "~" \
         $'\xc2\xb0'
do
  let "offset=offset+1"
  ord=`LC_CTYPE=C printf '%d' "'$c"`
  coffs[$ord]=$offset
  echo "    /* Next character: $c (ord $ord) at offset $offset */"
  convert -background white -fill black \
          -font Terminus-\(TTF\)${WEIGHT} -pointsize $POINTSIZE \
          -colors 2 +antialias label:"${c}" "${FN}" 2>/dev/null
  if [ ! -e "$FN" ] ; then
    echo "Failed to create bitmap from character '$c'."
    exit 1
  fi
  if [ "$BYTESPERCHAR" == "1" ] ; then
    hexvs=`tail -n -2 "${FN}" | sed -e 's/ };//' -e 's/,/ /g' -e 's/0x//g'`
    for l in $hexvs
    do
      rl=`echo $l | rev | tr '0123456789ABCDEF' '084C2A6E195D3B7F'`
      binv=`echo "obase=2; ibase=16; ${rl}" | bc | awk '{printf "%08d\n", $0}' | sed -e 's/0/ /g' -e 's/1/#/g'`
      echo "    0x${rl}, // ${binv}"
    done
  elif [ "$BYTESPERCHAR" == "2" ] ; then
    hexvs=`grep -v '#define' "${FN}" | grep -v '= {' | sed -e 's/ };//' -e 's/0x\(..\), 0x\(..\),/\1\2/g'`
    for l in $hexvs
    do
      rl=`echo ${l:2:2}${l:0:2} | rev | tr '0123456789ABCDEF' '084C2A6E195D3B7F'`
      binv=`echo "obase=2; ibase=16; ${rl}" | bc | awk '{printf "%16s\n", $0}' | sed -e 's/0/ /g' -e 's/1/#/g'`
      echo "    0x${rl:0:2}, 0x${rl:2:2}, // ${binv}"
    done
  else
    hexvs=`grep -v '#define' "${FN}" | grep -v '= {' | sed -e 's/ };//' -e 's/0x\(..\), 0x\(..\), 0x\(..\),/\1\2\3/g'`
    for l in $hexvs
    do
      rl=`echo ${l:4:2}${l:2:2}${l:0:2} | rev | tr '0123456789ABCDEF' '084C2A6E195D3B7F'`
      binv=`echo "obase=2; ibase=16; ${rl}" | bc | awk '{printf "%24s\n", $0}' | sed -e 's/0/ /g' -e 's/1/#/g'`
      echo "    0x${rl:0:2}, 0x${rl:2:2}, 0x${rl:4:2}, // ${binv}"
    done
  fi
  rm -f $FN
done

echo "};"
echo ""
echo "const struct font font_terminus${FONTHEIGHT}${BOLD} = {"
echo "    .data   = terminus${FONTHEIGHT}${BOLD}_data,"
echo "    .width  = ${FONTWIDTH},  /* Width */"
echo "    .height = ${FONTHEIGHT}, /* Height */"
echo "    .offsets = { /* Offsets to individual characters */"
for c in `seq 0 255`
do
  echo "        ${coffs[$c]},"
done
echo "    }"
echo "};"
echo ""

